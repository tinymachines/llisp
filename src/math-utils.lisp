(in-package :transformer)

(declaim (optimize (speed 3) (safety 0) (debug 0)))

(defun dot-product (a b)
  (declare (type (simple-array single-float (*)) a b))
  (let ((sum 0.0))
    (declare (type single-float sum))
    (dotimes (i (length a))
      (incf sum (* (aref a i) (aref b i))))
    sum))

(defun matrix-multiply (a b)
  (declare (type (simple-array single-float (* *)) a b))
  (let* ((m (array-dimension a 0))
         (k (array-dimension a 1))
         (n (array-dimension b 1))
         (result (make-array (list m n) :element-type 'single-float :initial-element 0.0)))
    (declare (type (simple-array single-float (* *)) result))
    (dotimes (i m)
      (dotimes (j n)
        (let ((sum 0.0))
          (declare (type single-float sum))
          (dotimes (p k)
            (incf sum (* (aref a i p) (aref b p j))))
          (setf (aref result i j) sum))))
    result))

(defun transpose (matrix)
  (declare (type (simple-array single-float (* *)) matrix))
  (let* ((m (array-dimension matrix 0))
         (n (array-dimension matrix 1))
         (result (make-array (list n m) :element-type 'single-float)))
    (declare (type (simple-array single-float (* *)) result))
    (dotimes (i m)
      (dotimes (j n)
        (setf (aref result j i) (aref matrix i j))))
    result))

(defun softmax (x &key (axis -1))
  (declare (type (simple-array single-float (*)) x))
  (let* ((max-val (reduce #'max x))
         (exp-x (map '(simple-array single-float (*))
                     (lambda (xi) (exp (- xi max-val)))
                     x))
         (sum-exp (reduce #'+ exp-x)))
    (map '(simple-array single-float (*))
         (lambda (ei) (/ ei sum-exp))
         exp-x)))

(defun layer-norm (x &optional gamma beta)
  (declare (type (simple-array single-float (*)) x))
  (let* ((n (length x))
         (mean (/ (reduce #'+ x) n))
         (variance (/ (reduce #'+ (map 'list (lambda (xi) (expt (- xi mean) 2)) x)) n))
         (std (sqrt (+ variance 1e-5)))
         (normalized (map '(simple-array single-float (*))
                          (lambda (xi) (/ (- xi mean) std))
                          x)))
    (if (and gamma beta)
        (map '(simple-array single-float (*))
             (lambda (ni gi bi) (+ (* ni gi) bi))
             normalized gamma beta)
        normalized)))

(defun relu (x)
  (declare (type single-float x))
  (max 0.0 x))

(defun scaled-uniform (fan-in fan-out)
  (let* ((scale (sqrt (/ 2.0 fan-in)))
         (result (make-array (list fan-in fan-out) :element-type 'single-float)))
    (dotimes (i fan-in)
      (dotimes (j fan-out)
        (setf (aref result i j)
              (* scale (- (random 2.0) 1.0)))))
    result))